<script>
const $ = s => document.querySelector(s);
let tasks = [];
let syncing = false;
let lastServerSync = 0;
let frozenLayout = null;
let editTimeout = null;
let autoSaveTimers = {};
let isTyping = false;

const tzFmt = new Intl.DateTimeFormat('he-IL', {
  timeZone: 'Asia/Jerusalem',
  hour12: false,
  hour: '2-digit', minute: '2-digit', second: '2-digit'
});

function fmt(t){
  t=Math.max(0,parseInt(t));
  let h=Math.floor(t/3600),m=Math.floor((t%3600)/60),s=t%60;
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
}
function badgeClass(st){
  if(st==='running') return 'badge running';
  if(st==='paused')  return 'badge paused';
  if(st==='pending') return 'badge pending';
  return 'badge done';
}

async function api(url, method="GET", body=null){
  try{
    const res=await fetch(url,{method,headers:{'Content-Type':'application/json'},body:body?JSON.stringify(body):null});
    return await res.json();
  }catch{return null;}
}

// ğŸ•’ × ×¢×™×œ×ª ×¢×¨×™×›×” 10 ×©× ×™×•×ª
function startEditLock(){
  isTyping = true;
  clearTimeout(editTimeout);
  editTimeout = setTimeout(()=>{isTyping=false;},10000);
}
function autoSaveTask(id){
  clearTimeout(autoSaveTimers[id]);
  autoSaveTimers[id] = setTimeout(()=>updateTask(id,true),1000);
}

// âœ… ×—×™×©×•×‘ ×—×“×© ×©×œ ×©×¢×ª ×¡×™×•× ×›×•×œ×œ×ª (×›×•×œ×œ ×¨×¦×”)
function computeOverallEndLocal(){
  const nowMs = Date.now();
  let base = nowMs;
  const ordered = [...tasks].sort((a,b)=>a.position-b.position);
  for(const t of ordered){
    if(["running","paused","pending"].includes(t.status)){
      base += (t.remaining||0)*1000;
    }
  }
  return tzFmt.format(new Date(base));
}

function computeTimesOnce(){
  const now = Date.now();
  const n = tasks.length;
  const r = tasks.findIndex(t => t.status === 'running');
  let layout = [];

  if (r === -1) {
    let base = now;
    for (let i = 0; i < n; i++) {
      const dur = Math.max(0, tasks[i].remaining) * 1000;
      layout.push({ id: tasks[i].id, start: base, end: base + dur });
      base += dur;
    }
  } else {
    const run = tasks[r];
    const elapsed = Math.max(0, run.duration - run.remaining);
    const startRun = now - elapsed * 1000;
    const endRun = startRun + run.duration * 1000;
    let end = startRun;
    for (let i = r - 1; i >= 0; i--) {
      const dur = Math.max(0, tasks[i].remaining) * 1000;
      layout.unshift({ id: tasks[i].id, start: end - dur, end: end });
      end -= dur;
    }
    layout.push({ id: run.id, start: startRun, end: endRun });
    let start = endRun;
    for (let i = r + 1; i < n; i++) {
      const dur = Math.max(0, tasks[i].remaining) * 1000;
      layout.push({ id: tasks[i].id, start: start, end: start + dur });
      start += dur;
    }
  }
  frozenLayout = layout;
}

async function syncState(force=false){
  if(isTyping) return; 
  const now = Date.now();
  if(syncing) return;
  if(!force && now - lastServerSync < 2000) return;
  syncing = true;
  const data = await api("/state");
  syncing = false;
  lastServerSync = now;
  if(!data || !data.ok) return;

  tasks = data.tasks;
  $("#workTotal").textContent = data.work_total_hhmmss || "00:00:00";
  $("#overallEnd").textContent = computeOverallEndLocal(); // ×ª××™×“ ×œ×—×©×‘ ×‘×¢×¦×× ×•
  $("#now").textContent = data.now || "";
  if (!tasks.some(t => t.status === "running"))
    frozenLayout = null;
  renderTasks(true);
}

function renderTasks(fromSync=false){
  if(isTyping) return;
  const tb=$("#tbody");
  tb.innerHTML="";
  if (!frozenLayout) computeTimesOnce();
  tasks.forEach((t,i)=>{
    const tr=document.createElement("tr");
    tr.id="row-"+t.id;
    tr.className=t.status;
    const canEdit=(t.status!=="running");
    const layout = frozenLayout ? frozenLayout.find(x=>x.id===t.id) : null;
    const startStr = layout ? tzFmt.format(new Date(layout.start)) : "-";
    const endStr   = layout ? tzFmt.format(new Date(layout.end))   : "-";
    tr.innerHTML=`
      <td>${i+1}</td>
      <td class="work-col"><input type="checkbox" class="work-flag" ${t.is_work?"checked":""}></td>
      <td><input class="edit-name" type="text" value="${t.name.replace(/"/g,'&quot;')}" ${canEdit?"":"disabled"}></td>
      <td><span class="remain" data-id="${t.id}">${fmt(t.remaining)}</span></td>
      <td>${startStr}</td>
      <td>${endStr}</td>
      <td><span class="${badgeClass(t.status)}">${t.status}</span></td>
      <td>
        <div class="edit-grid">
          <input class="edit-h" type="number" min="0" value="${Math.floor(t.duration/3600)}" ${canEdit?"":"disabled"}>:
          <input class="edit-m" type="number" min="0" value="${Math.floor((t.duration%3600)/60)}" ${canEdit?"":"disabled"}>:
          <input class="edit-s" type="number" min="0" value="${t.duration%60}" ${canEdit?"":"disabled"}>
        </div>
      </td>
      <td>
        <div class="extend-grid">
          <input class="ext-h" type="number" min="0" value="0">:
          <input class="ext-m" type="number" min="0" value="0">:
          <input class="ext-s" type="number" min="0" value="0">
          <button onclick="extendTask(${t.id})">×”××¨×š</button>
        </div>
      </td>
      <td>
        <div class="move-grid">
          <input class="move-to" type="number" min="1" value="${i+1}">
          <button onclick="moveTask(${t.id})">×”×¢×‘×¨</button>
        </div>
      </td>
      <td class="row-actions">
        <button onclick="action('/start/${t.id}')">×”×ª×—×œ</button>
        <button onclick="action('/pause/${t.id}')">×”×©×”×”</button>
        <button onclick="action('/reset/${t.id}')">××™×¤×•×¡</button>
        <button onclick="action('/set_pending/${t.id}')">Pending</button>
        <button onclick="action('/skip/${t.id}')">×“×œ×’</button>
        <button onclick="action('/delete/${t.id}')">××—×§</button>
      </td>`;
    tb.appendChild(tr);
    tr.querySelectorAll("input").forEach(inp=>{
      inp.addEventListener("focus", startEditLock);
      inp.addEventListener("input", e=>{
        startEditLock();
        const id = t.id;
        if(["edit-name","edit-h","edit-m","edit-s"].some(c=>e.target.classList.contains(c)))
          autoSaveTask(id);
      });
    });
    tr.querySelector(".work-flag").addEventListener("change", async e=>{
      t.is_work=e.target.checked;
      renderTasks();
      await api(`/workflag/${t.id}`, "POST", {is_work:e.target.checked});
      await syncState(true);
    });
  });
}

// ×”×©××¨ ×‘×“×™×•×§ ××•×ª×• ×“×‘×¨ ×›××• ×§×•×“×...
setInterval(()=>{
  const running=tasks.find(t=>t.status==="running");
  if(running){
    running.remaining=Math.max(0,running.remaining-1);
    if(running.remaining===0)running.status="done";
  }
  document.querySelectorAll(".remain").forEach(span=>{
    const t=tasks.find(x=>x.id==span.dataset.id);
    if(t)span.textContent=fmt(t.remaining);
  });
  $("#now").textContent=new Date().toLocaleTimeString("he-IL",{hour12:false});
  $("#overallEnd").textContent=computeOverallEndLocal(); // â¬…ï¸ ××¢×•×“×›×Ÿ ×›×œ ×”×–××Ÿ
},1000);
</script>